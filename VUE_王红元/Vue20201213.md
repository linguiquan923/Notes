

# Vue，第一天

## 1、插值操作

### v-once:，

被绑定的值是不会再产生变化的

```html
<div id="app">
  <h1>{{message}}</h1>
  <h1 v-once>{{message}}</h1>
</div>
```

### v-pre:

不会解析数据

![image-20201222101803463](Images\image-20201222101803463.png)

### v-cloak:

有时候js的会加载的比较慢，会直接把{{message}}展示给用户，所以我们添加进去这个组件可以实现，当vue解析之前，有这个属性的值会自动屏蔽，解析之后，才会显示

```html
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <style>
    [v-cloak]{
      display: none;
    }
  </style>
</head>
```

````html
<div id="app" v-cloak>
  <h1 >{{message}}</h1>
  <h1 v-pre>{{message}}</h1>
</div>

````

### v-bind:

动态数据绑定，此时img绑定的就是从data里面传来的url了，下面是语法糖的写法

```html
<img v-bind:src="url">
<img :src="url">
```

还可以绑定css的对象，用中括号括起来代表是个对象，可以用键值对的方法去匹配，如果值为true，那么就是使用，为false不使用，正常来说false和true的值由data传入

```html
<h2 v-bind:class="{active: true,line: false}">nihao </h2>
```

通过点击方法变化颜色，通过v-on绑定click时间，绑定到vue里面的change函数

```html
<h2 v-bind:class="{active: isActive,line: true}">nihao </h2>
  <buttun v-on:click="change">点击变色</buttun>
```

可以把{active: isActive,line: true}放进方法里面，然后调用

```html
  <h2 v-bind:class="getMethod()">nihao </h2>
```



```html
methods:{
        change: function () {
          this.isActive = !this.isActive
        },
        getMethod: function () {
          return {active: this.isActive,line: true}

        }
      }
```

## 作业：点击哪个电影哪个电影就变红

思路：1、利用对象，将设置class="{active: isActive1 == index}" ，此时设置isActive1为-1，当点击的时候传入index的值，将index的值赋给isAtctive1，此时isActive1 == index，那么值为true，显示红色

```html
<div id="app">
  <h1>{{message}}</h1>
  <h1 v-once>{{message}}</h1>
  <ul>
    <li v-for="(m,index) in movies" :index1="index" v-on:click="changeColor(index)" :class="{active: isActive1 == index}" >{{m}} {{index}}</li>
  </ul>
</div>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊',
      movies: ['老百姓','蜡笔小新','哈哈哈啊哈'],
      isActive: [false,false,false],
      isActive1: -1
    },

    props: ['index1'],
    methods: {
      changeColor: function(index1) {
        this.isActive1 = index1
      }
    }
  })
</script>
```



# #############2020.11.15##############

### v-bind动态绑定style，对象语法

```html
<div id="app">
  <h1 :style="getStyle()">{{message}}</h1>
</div>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊',
      color: 'green',
      fontSize: '100px'
    },
    methods:{
      getStyle: function () {
        return {color: this.color,fontSize: this.fontSize}
      }
    }
  })

</script>
```

# 第二天

### 1、计算属性：

​	计算属性是有缓存的，他的计算效率更高

1、按照属性去起名字，而不是带有方法，起名为fullName而不是getFullName

```html
computed:{
      fullName: function () {
        return this.message + ' ' + this.color
      }
    },
```

2、计算属性的复杂运算

​	可以将data里面的数据运算好再去调用

```html
computed: {
      totalPrice: function () {
        let sum = 0;
        for(let i = 0 ; i < this.movies.length ; i++){
          sum += this.movies[i].price
        }
        return sum
      }
    }
```

计算属性的原型是有get和set的

```vue
fullname: {
        set: function (newValue) {
          /*通过空格把字符串解析*/
          const name = newValue.split(' ');
          this.firstname = name[0];
          this.lastname = name[1];
        },
        get: function () {
          return this.firstname + " " + this.lastname;
        }
      }
```

只是不希望值被随意更改，所以正常都会省略set方法

### 2、计算属性和方法的对比

计算属性由于有缓存，性能会比方法更好

methods



computed



可以很明显对比得到，computed只调用了一次

### 3、v-on事件监听

语法糖：v-on  @

如果函数需要传入参数但是我们却没有传入参数，那么会给一个浏览器产生的event事件作为对象传入到方法中，

![image-20201222102101514](Images\image-20201222102101514.png)

![image-20201222102047994](Images\image-20201222102047994.png)

我们同时需要传入参数和event数值的时候，我们需要使用$event来获取浏览器鼠标点击事件

```html
 <button @click="click1(123,$event)">点击2</button>
```

#### v-on的修饰符

1、我们在一个div里面放置一个button，我们点击button的时候其实是会同时相应div定义的响应事件的

```html
<div @click="divClick">
    <button @click="btnClick">点击3</button>
  </div>
```

![image-20201222102236458](Images\image-20201222102236458.png)

我们若只想点击button的时候响应btn的事件，而不会连带div事件，那么只需要加上.stop

```html
<div @click="divClick">
    <button @click.stop="btnClick">点击3</button>
  </div>
```

![image-20201222102311158](Images\image-20201222102311158.png)

2、在form表单里面，我们点击submit按钮，若是想自己收集数据提交，那么只需要使用.prevent

```html
<form action="https://www.baidu.com">
    <input type="submit" value="提交" @click.prevent="formClick"/>
  </form>
```

![image-20201222102404967](Images\image-20201222102404967.png)

3、监听某个键盘的键帽

```html
<input type="text" @keyup="keyup" /> //监听所有的
<input type="text" @keyup.enter="keyup" /> // 监听enter的
```

4、键盘只需要被点击一次

```html
<button @click.once="click1(123,$event)">点击2</button>
```



### 4、v-if

```html
<h1>{{message}}</h1>
  <h1 v-if="score > 90">优秀</h1>
  <h1 v-else-if="score >= 80">良好</h1>
  <h1 v-else-if="score >= 60">及格</h1>
  <h1 v-else>不及格</h1>
```

条件很多的时候建议使用计算属性

简单的登录切换

```html
<span v-if="isUser">
    <label for="user">用户姓名</label>
    <input type="text" id="user" placeholder="用户姓名">
  </span>
  <span v-else>
    <label for="email">用户邮箱</label>
    <input type="text" id="email" placeholder="用户邮箱">
  </span>
```

由于vue的底层是会选择尽量使用虚拟dom里面的对象直接复用，如果不想复用的话，加上一个key

```html
<span v-if="isUser">
    <label for="user">用户姓名</label>
    <input type="text" id="user" placeholder="用户姓名" key="user">
  </span>
  <span v-else>
    <label for="email">用户邮箱</label>
    <input type="text" id="email" placeholder="用户邮箱" key="email">
  </span>
```

### 5、v-show

```html
<h1 v-show="true">{{message}}</h1>
```

v-if：当条件为false的时候，包含v-if的指令元素完全不会出现

v-show：条件为false的时候，只是添加了一个行内元素：display： none

如果显示和隐藏使用的很频繁的时候，使用v-show，频率不高的话使用v-if

### 6、v-for 

在使用v-for的时候一般要绑定key，绑定的key我习惯采用index

```vue
v-for="(item,index) in items" :key="index"
```

遍历数组

遍历对象

```html
<ul>
    <li v-for="(item,key,index) in info">
      {{key}}  : {{item}} : {{index}}
    </li>
  </ul>
```

尽量绑定绑定:key

没有绑定key的话，它做插入操作的时候的性能是十分低的，建议绑定一个key，而且key和循环出来的数据一一对应。

```html
<ul>
    <li v-for="i in movies" :key="i">{{i}}</li>
  </ul>
```

所以一句话，key的绑定是为了高效的更新虚拟DOM

### 7、数组中哪些方式是响应式的

响应式就是在虚拟dom修改后能够直接渲染的。

```html
		 //1.push
        // this.movies.push('111')

        //2.pop 移除数组最后一个元素
        // this.movies.pop()

        //3.shift 删除数组第一个元素
        // this.movies.shift()

        //4.unshift 数组最前面添加元素
        // this.movies.unshift('1111','2222','4444')

        //5.splice 删除元素，插入元素，替换元素
        //（start）
        //删除元素，第二个参数传入你要删除几个元素，
        // this.movies.splice(2,1)
        //替换元素，第二个参数表示我们要替换几个元素，后面传入要替换的元素
        // this.movies.splice(1,2,'a','a')
        //插入元素，第二个为0，后面添加要插入的参数就可以了
        // this.movies.splice(1,0,'2')

		//6.sort排序
        // this.movies.sort()

		//7.反转数组内容 reverse
        // this.movies.reverse()

		//8.可以通过set方法去通过索引值修改内容
		//this.movies.splice(index,1,content)
        // Vue.set(this.movies,index,content)
```

通过索引值改变修改数组中的值不是响应式的

```html
//这个称作可变参数，可以往里面添加很多数据，它会自动生成一个数组
sum(1,2,3,4,5,6,7)
function sum(...num){
	console.log(num)
}
```



## 1、图书购物车样例



### 1、设计思想

1、我们要先通过for循环去获取数据，并且存入表单，在表单添加增加和减少，移除的button

2、通过过滤器的方法把价格显示出来（<th>{{item.price | showPrice}} </th>）

3、实现增加和减少的函数功能，此时应该传入index，通过下标来修改count，并且判断当数量小于等于1 的时候减少按钮是无法使用的

4、增加移除的函数，通过splice的函数执行，但是在实际的应用中，我们应该直接删除数据库的内容

5、通过计算属性computed去计算总价格，然后显示出来



### 2、html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<div id="app">
  <table border="2">
    <thead>
      <th></th>
      <th>图书名称</th>
      <th>出版日期</th>
      <th>价格</th>
      <th>购买数量</th>
      <th>操作</th>
    </thead>
    <tbody>
      <tr v-for="(item,index) in books">
        <th>{{item.id}}</th>
        <th>{{item.name}}</th>
        <th>{{item.date}}</th>
<!--        <th>{{getPrice(item.price)}} </th>-->
        <th>{{item.price | showPrice}} </th>
        <th>
          <button @click="decrement(index)" :disabled="item.count <= 1">-</button>
          {{item.count}}
          <button @click="increment(index)" >+</button>
        </th>
        <th>
          <button @click="removeHandle(index)">移除</button>
        </th>
      </tr>
    </tbody>
  </table>
  <h1>总价格：{{totalPrice | showPrice}}</h1>

</div>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="main.js"></script>
</body>
</html>
```



### 3、js

```js
const app = new Vue({
  el: "#app",
  data:{
    books:[
      {
        id: 1,
        name: 'java',
        date: '2006-09',
        price: 85.00,
        count: 1
      },
      {
        id: 2,
        name: 'java1',
        date: '2006-09',
        price: 853.00,
        count: 1
      },
      {
        id: 12,
        name: 'jav3a',
        date: '2006-09',
        price: 845.00,
        count: 1
      },
      {
        id: 51,
        name: 'ja5va',
        date: '2006-09',
        price: 853.00,
        count: 1
      },
    ]
  },
  methods: {
    // getPrice(price){
    //   return "￥" + price.toFixed(2)
    // }
    increment(index){
      console.log("increment",index)
      this.books[index].count++
    },
    decrement(index){
      this.books[index].count--
    },
    removeHandle(index){
      this.books.splice(index,1);
    }
  },
  computed:{
    totalPrice(){
      let totalPrice = 0;
      //for(let i = 0 ; i < this.books.length ; i++){
       // totalPrice += this.books[i].count * this.books[i].price
     // }
     
        for(let book of this.books){
        totalPrice += book.price * book.count
      }
      return totalPrice
    }
  },

  filters: {
    showPrice(price) {
      return "￥" + price.toFixed(2)
    }
  }

})
```

# 第三天

### 1、高阶函数

#### 1、filter（筛选）

遍历num，传入函数中，如果满足n<20，则是返回true，那么n就会加入到newNums中

```html
 const num = [3,6,3,4,5,6,23,423,5,6,78]

  let newNums = num.filter(function (n) {
    return n < 20
  })
  console.log(newNums)
```

#### 2、map（计算）

遍历数组，把传入的n乘以2再传出给新的数组

```html
let newNums2 = newNums.map(function (n) {
    return n * 2
  })
  console.log(newNums2);
```



# ##################2020.11.16###################



#### 3、reduce（循环计算）

preValue的值是代表上一次传进去的值，0传入的值赋予给preValue，每次传出的值在下一次遍历开始之前赋予给preValue。

```html
movies = [3,4,5,6,4,7,233,4,5,3,3,22,3,4,556,33]
    let total = movies.reduce(function (preValue,n){
        return preValue + n;
    },0)
    console.log('total = ' + total);

```

把filter、map和reduce结合在一起满足条件，取出小于100的值并且把值乘以二之后相加

```html
 total = movies.filter(function (n){
        return n < 100
    }).map(function (n){
        return n * 2
    }).reduce(function (preValue,n){
        return preValue + n
    },0)
    console.log('total = ' + total);
```

可以使用更加简便的方法去书写

```html
total = num.filter(n => n < 100).map(n => n * 2).reduce((preV,n) => preV + n)
```



### 2、v-model

可以实现数据双向绑定，随着输入框内容的变动，所显示的内容也跟着变动

```html
  <input type="text" v-model="message"><br>
  <input type="text" :value="message" v-on:input="changContent"><br>
  <input type="text" :value="message" v-on:input="message = $event.target.value">	
```



#### 1、v-model和radio的绑定使用：

使用v-model绑定同一个对象的时候可以实现只选择一个，在data里面设置好属性可以设定默认值

v-model绑定的是data里面的数据

```html
<input type="radio" value="男" v-model="sex">男<br>
  <input type="radio" value="女" v-model="sex">女
  
  <h2>{{sex}}</h2>
```

#### 2、v-model和checkbox：

```html
 <!--1、checkbox的单选框，可以通过判断是否同意了该选项是否显示下一步按钮-->
  <input type="checkbox" v-model="isAgree">是否同意1
  <h1><input type="button" :disabled="!isAgree" value="下一步"></h1>
```



```html
 <!--2、checkbox复选框，在data里面定义数组，可以把v-model绑定相同的数据加入到数组-->
  <input type="checkbox" value="1" v-model="hobbies">1
  <input type="checkbox" value="2" v-model="hobbies">2
  <input type="checkbox" value="3" v-model="hobbies">3
  <input type="checkbox" value="4" v-model="hobbies">4
  <h1>{{hobbies}}</h1>

data: {
      hobbies: []
    },
```

#### 3、v-select

可以只绑定一个，也可以绑定数组

```html
<!--1、select-->
  <select name="fruit" v-model="fruit">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
  </select>
  <h1>{{fruit}}</h1>

  <!--2、select-->
  <select name="fruits" v-model="fruits" multiple>
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4">4</option>
  </select>
  <h1>{{fruits}}</h1>
```

#### 4、值绑定

可以通过for循环给checkbook赋值

```html
<label v-for="item in balls" :for="item">
    <input type="checkbox" :id="item" :value="item" v-model="hobbies">{{item}}
  </label>
  <h1>{{hobbies}}</h1>
```

#### 5、修饰符

##### 1、.lazy

当用户输入完点击回车或者点击浏览器的时候，那么这个值才会更新

```html
 <input type="text" v-model.lazy="message"/>
```



##### 2、.number

可以把输入的类型转换成数字类型

```html
<input type="text" v-model.number="age"/>
  <h1>{{typeof age}}</h1>
```

##### 3、.trim

可以自动去除空格

### 3、组件化开发

#### 1、全局组件

```html
//1、构建组件构造器对象
  const cpnC = Vue.extend({
    template: `
    <div>
    <h1>lgq</h1>
    <h1>lgq</h1>
    </div>
    `
  })
  //2、注册组件(全局组件,意味着可以在多个Vue实例下使用)
  Vue.component('my-t',cpnC)
```

#### 2、局部组件

```html
const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊'
    },
//cpn1是要使用的标签，cpnC是构造的组件
    components: {
      cpn1: cpnC
    }
  })
```

#### 3、父组件和子组件的区别

在组件cpn2中我们使用components注册了cpn1，那么cpn1就是cpn2的子组件，而cpn2是cpn1的父组件，在cpn2中我们可以直接使用cpn1，

```js
<script>
  const cpn1 = Vue.extend({
    template: `
    <div>
    <p>我是第一个组件</p>
    </div>
    `
  })
  const cpn2 = Vue.extend({
    template: `
    <div>
    <p>我是第2个组件</p>
    <cpn2_1></cpn2_1>
    </div>
    `,
    components:{
      cpn2_1: cpn1
    }
  })
  const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊'
    },
    components: {
      cpn2: cpn2
    }
  })
</script>
```

#### 4、语法糖

```js
Vue.component('my-t1',{
    template: `
    <div>
    <p>语法糖</p>
    </div>
    `
  })
```

```js
const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊'
    },
    components: {
      'cpn2': { template: `
      <div>
        <p>语法糖2222</p>
      </div>
      `}
    }
  })
```

#### 5、组件模板分离写法

使用script标签，ype使用text/x-template，赋值一个id，在template中获取id

```html
<script type="text/x-template" id="cpn1">
<div>
  <p>我是模板分离第一种方法</p>
</div>
</script>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  Vue.component('cpn1',{
    template: '#cpn1'
  })
```



6、直接使用template标签

```html
<template id = "cpn2">
  <div>
    <p>我是第二种方法</p>
  </div>
</template>
<script>
  Vue.component('cpn2',{
    template: '#cpn2'
  })
</script>
```

#### 组件里面的data必须为函数

data必须为函数，而且必须得包含一个return

```html
<template id="cpn1">
  <div>
    {{title}}
  </div>
</template>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  Vue.component('cpn1',{
    template: '#cpn1',
    data(){
      return{
        title: '我是组件里面的data'
      }
    }
  })
```

原因：如果为一个函数的话，那么返回的函数每次都是新的一个对象，而不是会重复使用一组数据，如果使用data的话，那么不同组件是会同时使用一组数据的

![image-20201117104014687](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201117104014687.png)



#### 7、父子组件之间的通信，父传子

父传子，先通过v-bind去把data里面的数据绑定，然后传给cpn1，cpn1里面用props去接收传递的数据，那么就可以直接在<cpn1>标签里面使用

```html
<div id="app">
<!--  <h1>{{message}}</h1>-->
  <cpn1 :cmessage="message" :cmovies="movies"></cpn1>
</div>


<template id="cpn1">
  <div>
    <h1>{{cmessage}}</h1>
    <ul v-for="item in cmovies">
      <li>{{item}}</li>
    </ul>
  </div>
</template>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>

  Vue.component('cpn1',{
    template: '#cpn1',
    props: ['cmessage','cmovies']
  })

  const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊',
      movies: ['1','2','3','4']
    },
    components:{
      template: {
        cpn1
      }
    }
  })
</script>
```

##### 1、props可以使用对象传值：

###### 1、提供类型限制



###### 2、提供一些默认值

```html
props:{
	//当传入的类型是数组或者是对象的时候，默认值必须为一个函数
	//cmovies:{
       // type: Array,
       // default(){
        //  return []
       // }
	  cmovies: Array,
	//cmessage: [String,Number] //传入多个可能类型
	  cmessage: {
        type: String, //设置类型
        default: 'aaaaaa', //设置默认值，如果没有传入的话就会默认显示
        required: true, //必须传入否则报错
      }, 
}
    }
```

##### 2、props驼峰标识

在传值给子组件的时候是不支持驼峰命名法的，只能采用-去标识，在props中能够识别

```html
<cpn1 :cmessage="message" :cmovies="movies" :my-message="myMessage"></cpn1>
```

```html
props:{
      myMessage: Object
    }
```



#### 8、父子组件之间的通信，子传父

1、先在子组件里面的模板创建一个点击事件，传入点击的item参数cpnClick(item)

2、使用this.$emit把参数发送出去，this.$emit('myclick',item);

3、在子组件设置监听发送的myclick事件，如果事件被发送响应，那么执行监听的函数myclick1

4、在myclick1接收到传递过来的数据，可以直接获取从子组件传递而来的数据

```html
<!--父组件-->
<div id="app">
  <cpn v-on:myclick="myclick1"></cpn>
</div>
<!--子组件-->
<template id="cpn">
  <div>
    <button v-for="item in data" @click="cpnClick(item)">{{item.name}}</button>
  </div>
</template>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
  Vue.component('cpn',{
    template: '#cpn',
    data(){
      return {
        data: [
            {id: 'aaa',name: '热门'},
            {id: 'bbb',name: '热门b'},
            {id: 'ccc',name: '热门c'},
            {id: 'ddd',name: '热门d'},
          ]
      }
    },
    methods:{
      cpnClick(item){
        this.$emit('myclick',item);
      }
    }
  })
  const app = new Vue({
    el: "#app",
    data: {
      message: '你好啊'
    },
    methods: {
      myclick1(item){
        console.log('-----myclick1',item)
      }
    }
  })
</script>
```

# 第四天

### 1、父子组件之间的访问方式，父访问子

可以通过$children[]的方法去访问子组件，并且可以调用子组件里面的方法和数据

```html
methods:{
      click(){
        this.$children[0].showMessage()
        console.log(this.$children[0].message);
      }
    },
```

开发的时候正常是使用**$refs**，需要在组件的里面设置ref的值，然后每次使用的都是指定组件的值

```html
<div id="app">
  <cpn ref="aaa"></cpn>
  <button @click="click">按钮</button>
</div> 
methods:{
      click(){
        this.$refs.aaa.showMessage()
      }
```

### 2、父子组件之间的访问方式，子访问父

可以通过this.$parent去访问父组件的元素，通过this.$root访问根组件的元素

```html
methods:{
              showMessage(){
                console.log('ccpn组件调用父组件 ' + this.$parent.message);
                console.log('ccpn调用root组件' + this.$root.message);
              }
            }
```



### 3、slot插槽

#### 1、基本使用

```html
<slot></slot>
```

#### 2、插槽的默认值使用，在插槽里面设置一个buttun，如果有输入值那么替换掉，如果没有的话会使用默认值

```html
<slot><buttun>按钮</buttun></slot>
```

#### 3、如果有多个值，同时放入到组件中运行，将会一起作为替换元素

```html
 <cpn>
    <p>1</p>
  </cpn>	
	<p>子组件</p>
    <slot><button>按钮</button></slot>
    <p>子组件</p>
```

### 4、slot具名插槽

在插槽里面使用name去表示插槽，然后使用的时候通过slot去指定使用哪个插槽

```html
<div id="app">
  <cpn>
    <button slot="left">返回</button>
    <button slot="right">菜单</button>
  </cpn>

</div>
<template id="cpn">
  <div>
    <p>子组件</p>
    <slot name="left">左边</slot>
    <slot name="center">中间</slot>
    <slot name="right">右边</slot>
    <p>子组件</p>
  </div>
</template>
```

### 5、作用域插槽的使用

父组件想更改显示样式，但是读取的数据要从子组件读出

在子组件的slot中使用:data绑定子组件中data的数据，然后在父组件中使用slot-scope='data'去获取绑定的值，data是可以随意命名的，就可以使用slot.data获取子组件里面的数据，slot.data.join('-')这个方法是把数组的数据转换成字符串，用-拼接起来

```html
<div id="app">
  <cpn></cpn>
<cpn>
  <div slot-scope="slot">
    <div >
      <span >{{slot.data.join('-')}}</span>
    </div>
  </div>
</cpn>
</div>
<template id="cpn">
  <div>
    <slot :data="pLanguage">
      <ul v-for="i in pLanguage">
        <li>{{i}}</li>
      </ul>
    </slot>
  </div>
</template>
```



### 6、ES6的模块化导入和导出

导入模块的时候要指定type为module

```html
<script src="../aaa.js" type="module"></script>
```

导出模块为export

```js
let a = '123'
class Person(){
    
}
function sum(){
}
export sum
export Person
export a
```

使用这些数据的模块是import

```js
import sum from 'aaa.js'
import Person from 'aaa.js'
import a from 'aaa.js'
```

可以使用export default，每个模块只能拥有一个default的方法

```js
export default sum
```

接收数据的可以使用自定义的方法名

```js
import sumTotal from 'aaa.js'
```



### 7、webpack

#### 1、安装webpack

全局安装

```java
npm install webpack@3.6.0 -g
```

##### 2、webpack的基本使用

​	在一个目录下同时有很多个js文件的时候，例如main和math，main是引入math的，我们使用

```js
webpack ./src/main.js ./dist/bundle.js
```

​	就可以把main.js打包成一个js文件

##### 3、webpack.config.js配置和package.json配置

​	实现：输入webpakc就能自动打包

```js
const path = require('path')

module.exports={
  //入口
  entry: './src/main.js',
  //打包好后要放的位置
  output:{
    //path: path.resolve(__dirname,'dist'),获取当前文件所在路径，是一个绝对路径
    path: path.resolve(__dirname,'dist'),
    filename: 'bundle.js'
  }
}
```

​	在当前目录下使用，当要求输入入口文件名的时候应该注意输入

```java
npm init 
```

​	会自动生成package.json

​	此时我们是有导入path包的，所以我们得使用

```java
npm install
```

​	导入这个包

​	最后使用，直接可以生成bundle.js文件

```java
webpack
```

​	我们可以在package.json文件里面添加build

```json
 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
```

那么我们执行npm run build的话会自动去执行webpack命令，放在package.json里面的webpack执行的时候，是会先去寻找本地安装的webpack执行，而不是去寻找全局安装的

本地安装webpack，在当前项目的文件下，--save-dev指的是开发时依赖

```java
npm install webpack@3.6.0 --save-dev
```

#### 2、Loader

##### 	这些模块的话是可以从webpack官网上直接抓取下来的

把css文件加入模块

```java
npm install --seva-dev css-loader
```

在webpack,config.js添加

```js
module: {
    rules: [
      {
        test: /\.css$/,
        //css-loader只负责解析不负责渲染
        use: [ 'css-loader' ]
      }
    ]
  }
```

运行，这时候会报错，因为我们默认下载的css-loader版本太高了，我们在package.json中修改为3.6.0就可以了

```java
npm run build
```

这个时候我们是无法看到效果的，引入style-loader

```java
npm install style-loader --save-dev 
```

在webpack,config.js添加

```js
module: {
    rules: [
      {
        test: /\.css$/,
        //css-loader只负责解析不负责渲染
        use: [ 'style-loader','css-loader' ]
      }
    ]
  }
```



# ##################2020.11.17####################



# 第五天

### 1、webpack-less的使用

#### 1、下载依赖包

应该注意less-loader的版本问题，

```html
npm install --save-dev less-loader less
```

#### 2、在webpack,config.js添加

```html
module.exports = {
    ...
    module: {
        rules: [{
            test: /\.less$/,
            use: [{
                loader: "style-loader" // creates style nodes from JS strings
            }, {
                loader: "css-loader" // translates CSS into CommonJS
            }, {
                loader: "less-loader" // compiles Less to CSS
            }]
        }]
    }
};
```

### 2、webpack-图片处理



#### 1、安装url-loader，如果图片过大要使用file-loader

#### 2、配置webpack,config.js



### 3、ES6转ES5

#### 1、使用babel就可以

##### 1、引入babel

```java
npm install --save-dev babel-loader@7 babel-core babel-preset-es2015
```



##### 2、配置文件

```java
{
      test: /\.js$/,
      exclude: /(node_modules|bower_components)/,
      use: {
        loader: 'babel-loader',
        options: {
          presets: ['es2015']
        }
      }
    }
```

#### 2、webpack-使用Vue的配置过程

##### 1、下载vue

```java
npm install vue --save
```

##### 2、引入vue

```java
import Vue from 'vue'
```

##### 3、修改Vue版本

因为我们默认使用的Vue版本是runtime-only，引入template会报错，我们修改指定Vue的版本，为runtime-complier，在webpack.config.js

```js
resolve:{
    alias: {
      'vue$': 'vue/dist/vue.esm.js'
    }
  },
```

##### 4、使用.vue文件开发

引入vue和template

```html
npm install vue-loader vue-template-compiler --save-dev
```

在webpack.config.js配置文件，module下面，在这里应该注意vue的版本问题，最好使用13.0.0的

```js
{
        test: /\.vue$/,
        use: [
          {
            loader: 'vue-loader',
            options: {}
          }
        ]
      },
```



#### 3、webpack-plugin

在webpack.config.js，配置发布版权，最后在生成的bundle.js文件头部有版权声明

```js
//引入plugin
const webpack = require('webpack')

module.exports={
  plugins:[
      new webpack.BannerPlugin('最终版权归aa所有')
  ]
}
```

#### 4、HtmlWebpackPlugin

因为我们发布文件的时候是没有办法把index.html发布出去的，所以我们需要这个插件

1、自动生成一个index.html文件

2、将打包的js文件通过script自动导入到html文件的body中，

导入html-webpack-plugin

应该注意html-webpack-plugin的版本

```java
npm install html-webpack-plugin --save-dev
```

在webpack.config.js

自动在dist导入index.html的时候会去自动寻找inde.html生成模板，所以我们的index.html应该修改，body里面只剩下一个div

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')
module.exports={
  plugins:[
      new webpack.BannerPlugin('最终版权归aa所有'),
      new HtmlWebpackPlugin({
        template: 'index.html'
      })
  ]
}
```

```html
<body>
<div id="app">

</div>
</body>
```



#### 4、uglifyjs-webpack-plugin

因为我们的js代码会太占空间，所以我们采用这个插件会压缩js文件

```java
npm install uglifyjs-webpack-plugin@1.1.1 --save-dev
```

在webpack.config.js配置

```js
const UglifyjsWebpackPlugin  = require('uglifyjs-webpack-plugin')
module.exports={
  plugins:[
      new webpack.BannerPlugin('最终版权归aa所有'),
      new HtmlWebpackPlugin({
        template: 'index.html'
      }),
      new UglifyjsWebpackPlugin()
  ]
}
```



#### 5、webpack-dev-server搭建本地服务器

想让浏览器自动刷新我们修改的结果

##### 1、安装

```java
npm install webpack-dev-server@2.9.1 --save-dev
```

##### 2、修改配置

```js
module.exports={
  devServer:{
    //监听的目录
    contentBase: './dist',
    //是否实时刷新
    inline: true
  }
}
```



##### 3、修改package.json

添加

```json
"dev": "webpack-dev-server"
"dev": "webpack-dev-server --open"//会自己直接打开8080端口
```

### 注意：

1、这里压缩js代码是推荐开发的时候不使用的，因为要调整不容易

2、发布之后这个webpack-dev-server是不使用的



#### 1、webpack配置文件分离

##### 1、下载插件

```java
npm install webpack-merge --save-dev
```

##### 2、创建build文件夹，下面创建三个js文件

使用webpack-merge

在prod.config.js里面引入base.config.js，然后利用webpackMerge把它们链接起来

```java
base.config.js //存放公共配置文件
```

```js
const path = require('path')

//引入plugin
const webpack = require('webpack')

const HtmlWebpackPlugin = require('html-webpack-plugin')

const UglifyjsWebpackPlugin  = require('uglifyjs-webpack-plugin')


module.exports={
  //入口
  entry: './src/main.js',
  //打包好后要放的位置
  output:{
    //path: path.resolve(__dirname,'dist'),获取当前文件所在路径，是一个绝对路径
    path: path.resolve(__dirname,'dist'),
    filename: 'bundle.js',

  },
  resolve:{
    alias: {
      'vue$': 'vue/dist/vue.esm.js'
    }
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        //css-loader只负责解析不负责渲染
        //style-loader负责将央视添加到DOM
        //使用多个loader，是自右向左读，所以css-loader会在style-loader后面
        use: [ 'style-loader','css-loader' ]
      },
      {
        test: /\.less$/,
        use: [{
          loader: "style-loader" // creates style nodes from JS strings
        }, {
          loader: "css-loader" // translates CSS into CommonJS
        }, {
          loader: "less-loader" // compiles Less to CSS
        }]
      },
      {
        test: /\.(png|jpg|gif|jepg)$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 13000
            }
          }
        ]
      },
      {
        test: /\.(png|jpg|gif|jepg)$/,
        use: [
          {
            loader: 'file-loader',
            options: {}
          }
        ]
      },
      {
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015']
          }
        }
      },
      {
        test: /\.vue$/,
        use: [
          {
            loader: 'vue-loader',
            options: {}
          }
        ]
      },
    ]
  },

  plugins:[
    new webpack.BannerPlugin('最终版权归aa所有'),
    new HtmlWebpackPlugin({
      template: 'index.html'
    }),
    // new UglifyjsWebpackPlugin()
  ],
  // devServer:{
  //   //监听的目录
  //   contentBase: './dist',
  //   //是否实时刷新
  //   inline: true
  // }

}
```





```java
prod.config.js //存放生产环境配置
```

```js
const UglifyjsWebpackPlugin  = require('uglifyjs-webpack-plugin')
const webpackMerge = require('webpack-merge')
const baseConfig = require('./base.config')

module.exports=webpackMerge(baseConfig,{
  plugins:[
    new UglifyjsWebpackPlugin()
  ],
})
```



```java
dev.config.js //存放开发环境配置
```

```js
const webpackMerge = require('webpack-merge')
const baseConfig = require('./base.config')

module.exports=webpackMerge(baseConfig,{
  devServer:{
    //监听的目录
    contentBase: './dist',
    //是否实时刷新
    inline: true
  }
})
```



##### 3、修改package.json里面的文件

指定启动时候加载的配置文件

```json
"build": "webpack --config ./build/prod.config.js",
"dev": "webpack-dev-server --config ./build/prod.config.js"
```

##### 4、修改发布的位置

因为我们这个时候修改了配置文件的位置，所以它打包生成的位置会在build下面，我们这个时候需要修改生成包的位置(base.config.js里面修改)

```js
 output:{
    //path: path.resolve(__dirname,'dist'),获取当前文件所在路径，是一个绝对路径
    path: path.resolve(__dirname,'../dist'),
    filename: 'bundle.js',

  },
```



### Vue-cli

1、CLI是command-Line Interface，翻译过来就是命令行界面，但是俗称脚手架

2、VUE CLI是一个官方发布的vue.js项目脚手架

3、使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置

4、Vue-cli依赖node，webpack

#### 1、安装Vue-cli

全局安装，这是安装Vue-cli3的，

```java
npm install -g @vue/cli@3.0.4
```

我们同时也想使用2的话就得下拉一个模板，这时候我们vue的2和3

都可以使用了

```java
npm install -g @vue/cli-init
```



vuecli2创建项目

```java
vue init webpack myvue
```

vuecli3创建项目

```java
vue create hello-cli3 
```





创建的项目各类包的内容
![image-20201118145420756](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201118145420756.png)





# 第六天

## 一、Vue Cli

### 1、runtime+compiler和runtime-only 的区别

![image-20201118152208187](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201118152208187.png)

只有在main.js有区别

runtime+compiler：template->ast->render->virtual dom -> UI(真实dom)

runtime-only:render->virtualdom->UI

#### 1、render函数的本质

![image-20201118152143701](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201118152143701.png)

最终createElement里面的东西会替换掉**<div id="app"></div>**里面的东西

我们的template会被vue-template-compiler解析成render函数

##### 1、runtime-only优点：

1、性能更高

2、代码量更少



### 2、vuecli3创建项目

#### 1、vuecli2和vuecli3的区别

![image-20201118153231982](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201118153231982.png)

```java
vue create vuecli3
```



### 3、修改配置

在终端输入，可以在ui界面修改配置

```java
vue ui
```

在目录下添加vue.config.js，可以修改配置文件和隐藏的配置文件合并

### 4、箭头函数

问题：箭头函数是如何查找this的

答案：箭头函数的this引用的是最近作用域的this，一层层向外寻找

```java
const a = function (){
    return true
}
const a = () => true
    
const b = function (){
    console.log()
}
const b = () => true //此时会返回一个undefined，默认有return返回

const sum = function(n1,n2){
    return n1 * n2
}
const sum = (n1,n2) => n1 * n2 
```



## 二、Vue Router

### 1、认识路由

#### 1、什么是路由

![image-20201118162142268](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201118162142268.png)

前端渲染后端渲染





### 2、vue-router基本使用

#### 1、url的hash和h5的pushState

使用这种方法去跳转的话，是不会刷新网页的

```html
location.hash = 'aaa'
history.pushState = ({},'','home')
```

#### 2、安装和使用vue-router

使用脚手架的时候选择 路由

路由的主文件为index.js，

```js
import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '../components/HelloWorld'

//使用vue-router，安装插件
Vue.use(Router)

//创建路由对象
export default new Router({
  //在这里配置路径和组件之间的关系，需要在main.js里面引入路由
  routes: [
    {
      //传入的路径
      path: '/',
      //路由名称
      name: 'HelloWorld',
      //传出路由的路径
      component: HelloWorld
    }
  ]
})

```

#### 3、完成路由转发route-link

创建好Home和About两个vue页面

##### 1、配置路由

```js
import Vue from 'vue'
import Router from 'vue-router'
import Home from '../components/Home'
import About from "../components/About";

//使用vue-router，安装插件
Vue.use(Router)

//创建路由对象
export default new Router({
  //在这里配置路径和组件之间的关系，需要在main.js里面引入路由
  routes: [
    {
      //传入的路径
      path: '/',
      //路由名称
      name: 'HelloWorld',
      //传出路由的路径

    },
    {
     path: '/home',
      name: 'Home',
      component:Home
    },
    {
      path: '/about',
      name: 'About',
      component:About
    },
  ]
})

```

##### 2、在App.vue使用路由

router-link是类似于a表现，而router-view是显示路由转发的内容

```vue
<template>
  <div id="app">

   <button><router-link to="/home">首页</router-link></button>
    <router-link to="/about">About</router-link>
    <router-view></router-view>
  </div>
</template>
```

##### 3、消除访问的#

在index.js下面routers加一个

```js
mode: 'history'
```



##### 4、route-link的其他属性

1、tag：修改渲染样式

```js
 <router-link to="/home" tag="button">首页</router-link>
```

2、replace：使其无法通过浏览器返回

```js
<router-link to="/about" tag="button" replace>About</router-link>
```



```
点击哪个路由会自带一个class .router-link-activ
```

3、只需要在style里面修改其样式就可以满足点击哪个按钮就变换样式

```vue
.router-link-active{
    color: darkred;
    transform: scale(1.5);
  }
```

4、可以自己修改点哪个路由活跃的class

在index.js下面的routers下面添加

```js
linkActiveClass: 'active'
```

然后在css中修改.active就可以



##### 5、通过代码监听实现跳转

通过$router去实现跳转

```vue
 <button @click="goHome">首页</button>
 <button @click="goAbout">About</button>
```

```js
methods:{
    goHome(){
      // this.$router.push('/home')
      this.$router.replace('/home') //无法返回
    },
    goAbout(){
      this.$router.push('/about')
      this.$router.replace('/about') //无法返回
    }
  }
```



# 第七天



### 3、动态路由

#### 1、传递参数

1、要先通过router-link的方式去传递要传的参数

绑定to，来把动态数据赋予给userId

用 '' 来表示/user/是一个字符串而不是变量

```vue
<router-link :to="'/user/'+userId" tag="button" replace>User</router-link>
```

2、在index.js中去配置传递参数

:userId来表示要传递的参数，在相对应的vue界面依靠这个来接收数据

```js
{
      path:'/user/:userId',
      name:'User',
      component:User
    }
```

3、在相对应的vue界面接收数据

然后就可以使用{{userId}}去使用这个参数了

```vue
computed:{
      userId(){
        return this.$route.params.userId
      }
    }
```

#### 2、认识路由懒加载

为什么需要路由懒加载

因为我们每次请求服务的话可能需要只请求某些数据，而不是把所有的数据都请求下来，如果把所有的数据都请求下来的话，那我们的响应可能会很慢，甚至可能出现短暂的空白

这是原本的路由

```js
import About from "../components/About";
import User from "../components/User";
export default new Router({
  //在这里配置路径和组件之间的关系，需要在main.js里面引入路由
  routes: [
    {
     path: '/home',
      name: 'Home',
      component:Home
    },
    {
      path: '/about',
      name: 'About',
      component:About
    },
})
```



路由懒加载

不会提前访问路由信息，值由点击的时候才会去访问

```js
const  Home = () => import('../components/Home')
const  About = () => import('../components/About')
export default new Router({
  //在这里配置路径和组件之间的关系，需要在main.js里面引入路由
  routes: [
    {
     path: '/home',
      name: 'Home',
      component:Home
    },
    {
      path: '/about',
      name: 'About',
      component:About
    },
})
```

# ##################2020.11.18#####################

### 4、vue-router嵌套路由

可以在一个路由里面再添加路由

#### 1、先添加两个Vue组件

#### 2、修改index.js文件

```js
{
     path: '/home',
      name: 'Home',
      component:Home,
      children:[
        {
          path: 'news',
          name: 'News',
          component: HomeNews
        },
        {
          path: 'message',
          name: 'Message',
          component: HomeMessage
        },
      ]
    },
```

利用children这个属性去配置子路由，里面的path是不可以添加'/'的，否则会报错，在Home里面的模板把这些显示出来即可

```vue
	<router-link to="/home/news">HomeNews</router-link>
    <router-link to="/home/message">HomeMessage</router-link>
    <router-view></router-view>
```



### 5、vue-router参数传递

#### 1、param传递

传递界面

```html
<router-link :to="'/user/'+userId" tag="button" replace>User</router-link>
```

路由界面

```html
{
      path:'/user/:userId',
      name:'User',
      component:User
    }
```

在接收界面

```html
computed:{
      userId(){
        return this.$route.params.userId
      }
    }
```

```java
$route为当前router跳转对象里面可以获取name、path、query、params等
    this.$route.params.userId

$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法
    this.$router.push('/about')
```



#### 2、query

```html
 <router-link :to="{path: '/profile' , query: {name: 'lgq',age: 23, height: 188}}" tag="button" replace>Profile</router-link>
```

用v-bind把to绑定，然后使用对象的形式去传入path和query，在路由的地方不需要变

```html
<p>{{this.$route.query}}</p>
```

query使用函数点击传递

query中携带参数

```vue
this.$router.push({
          path:'/detail',
          query:{
            iid:111
          }
        })
```

```vue
//接收的界面
this.iid = this.$route.query.iid
```



这样子就可以取到参数

### 6、vue-router导航守卫

#### 1、案例

可以满足跳转到哪个界面就可以更改相对应的title，在index.js修改

```js
const router = new Router({})
//使用全局路由导航，前置守卫(guard)
router.beforeEach((to,from,next)=>{
  //从from跳转到to
  document.title = to.matched[0].meta.title
  //必须实现，否则无法跳转
  next()
})
```

添加meta

```js
 {
      path: '/about',
      name: 'About',
      component:About,
      meta:{
        title: "关于"
      },
    },
```

#### 2、为什么使用导航守卫

meta：元数据（描述数据的数据）



#### 3、路由独享守卫(beforeEnter)

```vue
{
     path: '/home',
      name: 'Home',
      component:Home,
      meta:{
       title: "首页"
      },
      beforeEnter: (to,from,next)=>{
        console.log("这是Home的路由守卫")
        next()
      }
    },
```

#### 4、组件内的守卫



# ###################2020.11.19####################





### 7、keep-alive

为了保留组件的状态，避免组件被重新渲染

在App上面添加

```vue
<keep-alive>
      <router-view></router-view>
    </keep-alive>
```

在要保持状态的页面添加

```html
//这两个函数只有当keep-alive使用的时候才会生效
    activated() {
      this.$router.push(this.path)
    },
    deactivated() {
      console.log("deactivated")
    },
    beforeRouteLeave(to,from,next){
      console.log(this.$route.path)
      this.path = this.$route.path
      next()
    }
```

#### 1、exclude

想把哪一个组件排除在外让他重新创建，利用这个属性

```vue
<keep-alive exclude="Profile,User">
```

#### 2、include

把哪个组件包含在内



# ###################2020.11.22####################



### 8、TabBar

完成底部一个导航栏的示例

#### 1、先创建一个底部的tabbar

```vue
<template>
  <div>
    <div id="tabbar">
        <slot></slot>
    </div>
  </div>
</template>

<script>
  export default {
    name: "Tabbar"
  }
</script>

<style scoped>
  #tabbar{
    display: flex;
    text-align: center;
    height: 49px;

    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #f8f8f8;
    box-shadow: 0 -3px 1px rgba(100,100,100,0.1);
  }


</style>

```

#### 2、在App里面引入这个组件，并且使用它

```vue
import Tabbar from "./components/tabbar/Tabbar";
```

```vue
<div id="app">
    <Tabbar></Tabbar>
  </div>
```

#### 3、创建tabbarItem，并且在App导入使用它

```vue
<template>
    <div class="tab-bar-item">
      <slot name="item-icon"></slot>
      <slot name="item-text"></slot>

<!--      <img src="../../assets/img/tabbar/shouye1.png">-->
<!--      <div>首页</div>-->
    </div>
</template>

<script>
  export default {
    name: "TabbarItem"
  }
</script>

<style scoped>

  .tab-bar-item{
    flex: 1;
    text-align: center;
    height: 49px;
  }
  .tab-bar-item img{
    width: 24px;
    height: 24px;
    vertical-align: middle;
  }
</style>

```



```vue
import TabbarItem from "./components/tabbar/TabbarItem";
```

#### 4、最后App的样式（使用了具名插槽，反向向tabbarItem写入）

```vue
<template>
  <div id="app">
    <Tabbar>
      <TabbarItem>
        <img slot="item-icon" src="./assets/img/tabbar/shouye1.png">
        <div slot="item-text">首页</div>
      </TabbarItem>
      <TabbarItem>
        <img slot="item-icon" src="./assets/img/tabbar/fenlei1.png">
        <div slot="item-text">分类</div>
      </TabbarItem>
      <TabbarItem>
        <img slot="item-icon" src="./assets/img/tabbar/gouwuche1.png">
        <div slot="item-text">购物车</div>
      </TabbarItem>
      <TabbarItem>
        <img slot="item-icon" src="./assets/img/tabbar/wode1.png">
        <div slot="item-text">我的</div>
      </TabbarItem>
    </Tabbar>
  </div>
</template>

<script>
  import Tabbar from "./components/tabbar/Tabbar";
  import TabbarItem from "./components/tabbar/TabbarItem";
export default {
  name: 'App',
  components: {
    Tabbar,
    TabbarItem
  }
}
</script>

<style>
  @import "assets/css/base.css";

</style>

```

#### 5、通过点击来显示图片和文本的样式

​	（1）、要先把显示的图片全部插入，文本颜色也一样

tabbarItem.vue

最好是最外层用一个div把他们包裹住，他们就不会轻易改动差凑里面的数据的

```vue
<div v-if="!isActive" ><slot name="item-icon"></slot></div>
<div v-else><slot name="item-icon-active"></slot></div>
<div :class="{active: !isActive}"><slot name="item-text"></slot></div>
```

App.vue

```vue
<img slot="item-icon" src="./assets/img/tabbar/shouye1.png">
<img slot="item-icon-active" src="./assets/img/tabbar/shouye2.png">
```

#### 6、路由结合

​	（1）、在路由上添加各个指向

```vue
{
      path: '/home',
      name: 'Home',
      component: Home
    },
```

​	（2）、在对应的包下面创建vue文件

​				正常来说的话，components的包是要放公用的文件，比如说tabbar

​				我们这里采用	views/home/Home.vue 去创建Home的界面，这是为了方便以后修改，建议采用

![image-20201126153147954](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201126153147954.png)

​	（3）、修改App.vue里面的东西，实现路由跳转

把要跳转到的路径传给tabbaritem

```vue
<TabbarItem path="/home">
```

​	（4）、修改tabbarItem

添加鼠标点击事件，用props去接收path，然后由路由去转发对应的路径

```vue
<div class="tab-bar-item" @click="itemClick">

props:['path'],
    methods:{
      itemClick(){
        console.log(this.path)
        this.$router.push(this.path)
      }
    }
```



#### 7、使用传入的css颜色样式

​	要在使用这个Vue界面先传入颜色

```vue
<TabbarItem path="/home" activeColor="blue">
```

​	接收传入的颜色，并且设置默认值

```vue
props:{
      activeColor:{
        type: String,
        default: 'red'
      }
    },
```

​	

（1）、使用计算属性判断是否按钮处于活跃状态，如果是的话那么添加颜色

```vue
computed:{
      isActiveColor(){
        return this.isActive ? {color: this.activeColor} : {}
      }
    },
```

​	（2）、通过style的方式修改颜色

```vue
<div :style="isActiveColor"><slot name="item-text"></slot></div>
```

#### 8、可以把App里面的代码抽取出来，放在Main里面，然后App只需要引入一个Main就可以了

# #################2020.11.26######################

#### 9、起别名

可以解决文件的引用路径问题

1、首先在build/webpack.base.conf.js里面添加要起别名的内容

```js
 resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      '@': resolve('src'),
      'assets': resolve('src/assets'),
      'components': resolve('src/components'),
      'views': resolve('src/views'),

    }
  },
```

使用的时候直接引用就可以，只有在import可以这样子

```vue
import Tabbar from "components/tabbar/Tabbar";
```

在标签里面引用的话需要添加~

```vue
<img slot="item-icon" src="~assets/img/tabbar/shouye1.png">
```

### 9、Promise

当有多个请求的时候用Promise去封装它，可以清晰的看到请求的次序和顺序

使用

```js
new Promise((resolve, reject)=>{
    //第一次网络请求
    setTimeout(()=>{
      resolve('hello world');
    },2000)
  }).then((data)=>{
    //第一次拿到结果处理代码
    console.log(data);
    //第二次网络请求
    return new Promise(((resolve, reject) => {
      setTimeout(()=>{
        reject('error')
      },1000)
    })).catch((err)=>{{
        //第二次拿到结果处理代码
      console.log(err);
    }})

  })
```

Promist的三种状态

![image-20201130102230229](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201130102230229.png)



#### 1、Promist.all使用

需求：比如我们需要同时满足请求一和请求二，然后才能完成功能，那么我们只需要使用Promise.all就可以,

这时候会等待两个setTime都执行完之后才会打印出内容

```js
<script>
  Promise.all([
      new Promise((resolve, reject) => {
        setTimeout(()=>{
          resolve({name: 'james',age: 36})
        },1000)
      }),
      new Promise((resolve, reject) => {
        setTimeout(()=>{
          resolve({name: 'kobe',age:42})
        },3000)
      })
  ]).then(results=>{
    console.log(results);
  })
</script>
```



## 三、Vuex

存放需要共享的数据

![image-20201130105905496](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201130105905496.png)

![image-20201130110156249](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201130110156249.png)



### 1、下载vuex

```java
npm install vuex --save
```

### 2、创建store/index.js

### 3、编辑index.js文件

```js
import Vue from 'vue'
import Vuex from 'vuex'

//1、安装插件
Vue.use(Vuex)

//2、创建对象
const store = new Vuex.Store({
  state: {
    counters: 100
  },
  mutations: {

  },
  actions: {

  },
  getters: {

  },
  modules: {

  }
})

//3、导出store独享
export default store

```

### 4、在main.js注册

```js
import store from "./store";

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  store,
  router,
  render: h => h(App)
})
```

5、state在组件中使用

```vue
<template>
  <div>
    <h2>{{$store.state.counters}}</h2>
  </div>
</template>
```



### 5、如果要实现修改store里面的数据的话，需要Dispatch->commit，而不能直接使用$去调用

![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201130115642509.png)

### 6、muations（Vuex的方法）

#### 1、在vuex的写法

```js
mutations: {
    //方法
    increment(state){
      state.counters++
    },
    decrement(state){
      state.counters--
    }
  },
```

#### 2、在调用的组件的写法，得用commit的方法，提交更新

```vue
methods:{
    add(){
      this.$store.commit('increment')
    },
    sub(){
      this.$store.commit('decrement')
    }
  }
```

#### 3、在使用mutations中携带参数

index.js

```vue
addCount(state,count){
      state.counters += count
    }
```

App.vue

```vue
addCount(count){
      this.$store.commit('addCount',count)
    }
```

#### 4、mutations的类型常量

因为我们平时容易打错字，所以官方推荐使用这种方法，新建一个mutations-types.js文件

```js
export const INCREMENT = 'increment'
```

然后在要使用这个increment的地方导入，因为不是export default，所以要用中括号

```vue
 import{
    INCREMENT
  } from "./store/mutations-types";

//就可以直接使用了
this.$store.commit(INCREMENT)
```

但是在index.js文件中要加一个中括号

```js
mutations: {
    //方法
    [INCREMENT](state){
      state.counters++
    },
}
```



### 7、getters

相当于计算属性computed

#### 1、返回指定年龄范围的student

```vue
 getters: {
    //计算属性
    more20(state){
      return state.students.filter(s => s.age > 30)
    },}
```

```vue
{{$store.getters.more20}}
```

#### 2、返回长度

```vue
more20Length(state,getters){
      return getters.more20.length
    },
```

#### 3、返回指定的年龄范围，用户输入

```js
moreAge(state){
      return function (age) {
        return state.students.filter(s => s.age > age)
      }
    }
```

### 8、action异步操作

#### 1、在App.vue中修改，使用dispatch传递参数

```vue
update(){
      this.$store.dispatch('aUpdate','i am dispatch')
    }
```

#### 2、index.js，在index.js中还是调用mutations中的方法，因为修改store中的数据只能在mutations中修改

```js
actions: {
    aUpdate(context,payload){
      setTimeout(()=>{
        context.commit('update')
        console.log(payload);
      },2000)
    }
  },
```

#### 3、完成操作之后利用Promise的方法回调函数

因为this.$store.dispatch('aUpdate','i am dispatch')调用的返回一个Promise，所以相当于本身这部分就是一个Promise，我们这时候可以直接使用.then

App.vue

```vue
update(){
      this.$store.dispatch('aUpdate','i am dispatch').then((res)=>{
        console.log('我是App的数据');
        console.log(res);
      })
    }
```

index.js

```js
actions: {
    aUpdate(context,payload){
      return new Promise((resolve, reject) => {
        setTimeout(()=>{
          context.commit('update')
          console.log(payload);

          resolve('我是从vuex传回来的数据')
        },2000)

      })
    }
  },
```

### 9、modules模块封装

index.js

```js
modules: {
    a: moduleA
  }
```

```js
const moduleA = {
  state:{
    name: 'zhangsan'
  },
  mutations:{
    updateName(state,payload){
      state.name = payload
    }
  }
}
```

App.vue，a不需要再添加state

```vue
 <h2>{{$store.state.a.name}}</h2>
```

```vue
updateName(){
      this.$store.commit('updateName','lisi')
    }
```

commit可以直接提交，会自动搜索mutations里面的名字，不建议modules的mutations方法名相同，getters用法一致

#### 1、getters

```vue
getters:{
    fullname(state){
      return state.name + '1111'
    },
    fullname1(state,getters){
      return getters.fullname + '22222'
    },
    fullname2(state,getters,rootState){
      return getters.fullname + '22222' + rootState.counters
    },

  }
```

#### 2、actions

```js
actions:{
    aUpdateName(context){
      setTimeout(()=>{
        context.commit('updateName','i am the moduleA')
      },2000)

    }
  }
```

在actioon中，commit只会寻找当前module的mutations

### 10、在vue中，我们推荐把各类都分离出去

module建议分成一个包，因为会有很多的模块

![image-20201130161407880](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201130161407880.png)

## 四、网络请求分装(axios)

### 1、下载axios

```java
npm install axios --save
```

### 2、axios的基本使用

```java
axios({
  url: 'http://123.207.32.32:8000/home/multidata',
  method: 'get',
  
}).then((res)=>{
  console.log(res);
})
```

### 3、axios.all发送并请求

axios.all可以放入多个请求

```java
axios.all([
  axios({
    url: 'http://123.207.32.32:8000/home/multidata'
  }),
  axios({
    url: 'http://123.207.32.32:8000/home/data',
    params:{
      type: 'sell',
      page: 5
    }
  })
]).then((res)=>{
  console.log(res);
})
```

### 4、axios的配置信息

配置全局

```js
axios.defaults.baseURL = 'http://123.207.32.32:8000'
axios.defaults.timeout = 5000
```

### 5、axios的实例和封装

使用第三方的插件的时候，最好采用自己封装好第三方插件，然后让自己的组件面向自己封装的文件去编程

```js
//创建axios的实例
const instance1 = axios.create({
  baseURL: 'http://123.207.32.32:8000',
  timeout: 5000
})
instance1({
  url: '/home/multidata'
}).then((res)=>{
  console.log(res);
})

instance1({
  url: '/home/data',
  params:{
    type: 'sell',
    page: 5
  }
}).then((res)=>{
  console.log(res);
})

```

#### 1、使用Promise去封装

request.js

```js
import axios from 'axios'

export function request(config) {
    return new Promise(((resolve, reject) => {
      //1.创建axios的实例
      const instance = axios.create({
        baseURL: 'http://123.207.32.32:8000',
        timeout: 5000
      })

      //发送真正的网络请求
      instance(config)
        .then(res => {
        resolve(res)
      })
        .catch(err => {
        reject(err)
      })
    }))
}

```

```js
//使用封装的axios
request({
  url: '/home/data',
  timeout: 5000
}).then(res => {
  console.log(res);
}).catch(err => {
  console.log(err);
})

```

#### 2、直接返回

```js
import axios from 'axios'
export function request(config) {
      //1.创建axios的实例
      const instance = axios.create({
        baseURL: 'http://123.207.32.32:8000',
        timeout: 5000
      })
      //发送真正的网络请求
      return instance(config)
}
```

```js
//使用封装的axios
request({
  url: '/home/data',
  timeout: 5000
}).then(res => {
  console.log(res);
}).catch(err => {
  console.log(err);
})
```

# ##################2020.11.30#####################



### 6、axios拦截器

```js
//1.创建axios的实例
      const instance = axios.create({
        baseURL: 'http://123.207.32.32:8000',
        timeout: 5000
      })

      //2、axios拦截器的使用
      //2.1请求拦截
      instance.interceptors.request.use((config) => {
        //1、比如config中有一些要求不符合服务器的要求
        //2、比如每次发送网络请求的时候，都希望在页面中显示一个请求的图标
        //3、某些网络请求必须携带一些特俗的信息
        // console.log(config);
        return config
      },(err) => {
        // console.log(err);
      })

      //2.1响应拦截
	 //如果访问成功的话那么会在这里有访问信息，正常的话是返回res.data，只返回data数据
      instance.interceptors.response.use((res)=>{
        // console.log(res);
        return res.data
      },(err)=>{
        console.log(err);
      })


      //3.发送真正的网络请求
      return instance(config)
```

### 五、GitHub使用

有专属的文档







